/**
 * @file runtime.c
 * @brief Runtime library for Tiger programs
 * 
 * This file provides the runtime support functions that Tiger programs
 * can call. These functions are linked with compiled Tiger code to provide:
 * 
 * - Memory management: Array and record allocation
 * - String operations: Comparison, concatenation, substring, etc.
 * - I/O operations: Print, printi, flush, getchar
 * - Type conversions: ord, chr
 * - Program entry point: main() calls tigermain()
 * 
 * The runtime uses a simple string representation: length-prefixed arrays.
 * Arrays and records are allocated on the heap using malloc().
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/**
 * @brief Main entry point for compiled Tiger programs
 * 
 * This function is generated by the compiler and contains the user's
 * Tiger program code.
 */
extern int tigermain();

/**
 * @brief Test function: sum seven arguments
 * 
 * Used for testing function calls with many arguments (testing calling convention).
 */
int sum_seven(int v1, int v2, int v3, int v4, int v5, int v6, int v7) {
  return v1 + v2 + v3 + v4 + v5 + v6 + v7;
}

/**
 * @brief Initialize a new array with a given value
 * @param size Number of elements
 * @param init Initial value for all elements
 * @return Pointer to allocated and initialized array
 */
long *init_array(int size, long init) {
  int i;
  long *a = (long *)malloc(size * sizeof(long));
  for (i = 0; i < size; i++) a[i] = init;
  return a;
}

/**
 * @brief Allocate a new record (struct)
 * @param size Size in bytes
 * @return Pointer to allocated and zero-initialized record
 */
int *alloc_record(int size) {
  int i;
  int *p, *a;
  p = a = (int *)malloc(size);
  for (i = 0; i < size; i += sizeof(int)) *p++ = 0;
  return a;
}

/**
 * @brief Tiger string representation
 * 
 * Strings are length-prefixed arrays. The chars array is variable-length
 * (allocated with extra space beyond the single element declared).
 */
struct string {
  int length;           ///< String length
  unsigned char chars[1]; ///< Character data (variable length)
};

/**
 * @brief Compare two strings for equality
 * @param s First string
 * @param t Second string
 * @return 1 if equal, 0 otherwise
 */
int string_equal(struct string *s, struct string *t) {
  int i;
  if (s == t) return 1;
  if (s->length != t->length) return 0;
  for (i = 0; i < s->length; i++)
    if (s->chars[i] != t->chars[i]) return 0;
  return 1;
}

/**
 * @brief Print a string to stdout
 * @param s String to print
 */
void print(struct string *s) {
  int i;
  unsigned char *p = s->chars;
  for (i = 0; i < s->length; i++, p++) putchar(*p);
}

/**
 * @brief Print an integer to stdout
 * @param k Integer to print
 */
void printi(int k) { printf("%d", k); }

/**
 * @brief Flush stdout buffer
 */
void flush() { fflush(stdout); }

struct string consts[256];  ///< Pre-allocated single-character strings
struct string empty = {0, ""};  ///< Empty string constant

/**
 * @brief Program entry point
 * 
 * Initializes the runtime (character constants) and calls the compiled
 * Tiger program's main function (tigermain).
 * 
 * @return Exit code from tigermain()
 */
int main() {
  int i;
  for (i = 0; i < 256; i++) {
    consts[i].length = 1;
    consts[i].chars[0] = i;
  }
  return tigermain(0 /* static link */);
}

/**
 * @brief Get ASCII value of first character
 * @param s String
 * @return ASCII value of first character, or -1 if string is empty
 */
int ord(struct string *s) {
  if (s->length == 0)
    return -1;
  else
    return s->chars[0];
}

/**
 * @brief Convert integer to single-character string
 * @param i ASCII value (0-255)
 * @return Pointer to single-character string
 * @note Exits program if i is out of range
 */
struct string *chr(int i) {
  if (i < 0 || i >= 256) {
    printf("chr(%d) out of range\n", i);
    exit(1);
  }
  return consts + i;
}

/**
 * @brief Get string length
 * @param s String
 * @return Length of string
 */
int size(struct string *s) { return s->length; }

/**
 * @brief Extract substring
 * @param s Source string
 * @param first Starting position
 * @param n Number of characters
 * @return New string containing substring
 * @note Exits program if indices are out of range
 */
struct string *substring(struct string *s, int first, int n) {
  if (first < 0 || first + n > s->length) {
    printf("substring([%d],%d,%d) out of range\n", s->length, first, n);
    exit(1);
  }
  if (n == 1) return consts + s->chars[first];
  {
    struct string *t = (struct string *)malloc(sizeof(int) + n);
    int i;
    t->length = n;
    for (i = 0; i < n; i++) t->chars[i] = s->chars[first + i];
    return t;
  }
}

/**
 * @brief Concatenate two strings
 * @param a First string
 * @param b Second string
 * @return New string containing a followed by b
 */
struct string *concat(struct string *a, struct string *b) {
  if (a->length == 0)
    return b;
  else if (b->length == 0)
    return a;
  else {
    int i, n = a->length + b->length;
    struct string *t = (struct string *)malloc(sizeof(int) + n);
    t->length = n;
    for (i = 0; i < a->length; i++) t->chars[i] = a->chars[i];
    for (i = 0; i < b->length; i++) t->chars[i + a->length] = b->chars[i];
    return t;
  }
}

/**
 * @brief Logical negation
 * @param i Integer (0 or non-zero)
 * @return 1 if i is 0, 0 otherwise
 */
int not(int i) { return !i; }

#undef getchar

/**
 * @brief Read a character from stdin
 * @return Single-character string, or empty string on EOF
 * 
 * Wrapper around getc() to return a Tiger string.
 */
struct string *__wrap_getchar() {
  int i = getc(stdin);
  if (i == EOF)
    return &empty;
  else
    return consts + i;
}